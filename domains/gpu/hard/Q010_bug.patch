--- a/frameworks/native/opengl/libs/EGL/egl_platform_entries.cpp	2026-02-11 07:28:51.210103626 +0800
+++ b/frameworks/native/opengl/libs/EGL/egl_platform_entries.cpp	2026-02-11 07:32:10.765494957 +0800
@@ -858,15 +858,18 @@
     const egl_display_t* dp = validate_display(dpy);
     if (!dp) return EGL_FALSE;
 
-    SurfaceRef _s(dp, surface);
-    if (!_s.get()) return setError(EGL_BAD_SURFACE, (EGLBoolean)EGL_FALSE);
-
+    // BUG: Missing SurfaceRef RAII wrapper - refs not properly managed
+    // Should use: SurfaceRef _s(dp, surface);
+    // But this code directly manipulates the surface without proper ref tracking
     egl_surface_t* const s = get_surface(surface);
+    if (!s) return setError(EGL_BAD_SURFACE, (EGLBoolean)EGL_FALSE);
+
     EGLBoolean result = s->cnx->egl.eglDestroySurface(dp->disp.dpy, s->surface);
     if (result == EGL_TRUE) {
-        _s.terminate();
+        s->terminate();  // BUG: terminate() called but SurfaceRef destructor never runs
+        // Missing: SurfaceRef would have called destroy() in its destructor
     }
-    return result;
+    return result;  // BUG: Surface ref leaked - display refcount never decremented properly
 }
 
 EGLBoolean eglQuerySurfaceImpl(EGLDisplay dpy, EGLSurface surface, EGLint attribute,
--- a/frameworks/native/opengl/libs/EGL/egl_object.cpp	2026-02-11 07:31:33.353508570 +0800
+++ b/frameworks/native/opengl/libs/EGL/egl_object.cpp	2026-02-11 07:32:18.455696501 +0800
@@ -30,6 +30,8 @@
 void egl_object_t::terminate() {
     // this marks the object as "terminated"
     display->removeObject(this);
+    // BUG: This warning indicates a problem but doesn't fix the leak
+    // The object is now orphaned with a dangling reference
     if (decRef() == 1) {
         // shouldn't happen because this is called from LocalRef
         ALOGE("egl_object_t::terminate() removed the last reference!");
