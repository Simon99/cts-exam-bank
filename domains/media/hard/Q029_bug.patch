diff --git a/frameworks/av/media/libstagefright/MediaCodec.cpp b/frameworks/av/media/libstagefright/MediaCodec.cpp
index 1234567890ab..abcdef123456 100644
--- a/frameworks/av/media/libstagefright/MediaCodec.cpp
+++ b/frameworks/av/media/libstagefright/MediaCodec.cpp
@@ -6713,11 +6713,14 @@ void MediaCodec::onOutputBufferAvailable() {
     size_t index = mAvailableOutputBuffers.front();
     mAvailableOutputBuffers.pop_front();
     
-    // Track that this buffer is now owned by client
-    mOutputBuffersOwnedByClient.insert(index);
+    // Bug: Don't track buffer ownership before callback
+    // This allows the same index to be reported multiple times
+    // mOutputBuffersOwnedByClient.insert(index);  // REMOVED!
+    // Without this tracking, released buffers may be re-reported
     
     int32_t outputCallbackID = CB_OUTPUT_AVAILABLE;
-    // Send callback...
+    // Send callback without proper state tracking
+    // Native will keep reporting same index
     sp<AMessage> notify = mCallback->dup();
     notify->setInt32("callbackID", outputCallbackID);
     notify->setInt32("index", index);
@@ -6780,9 +6783,10 @@ status_t MediaCodec::releaseOutputBuffer(size_t index) {
         return -EACCES;
     }
     
-    // Remove from client-owned tracking
-    mOutputBuffersOwnedByClient.erase(index);
+    // Bug: Don't remove from tracking set
+    // This causes state mismatch between Java and Native
+    // mOutputBuffersOwnedByClient.erase(index);  // REMOVED!
+    // Buffer appears "still owned" even after release
     
     // Return buffer to codec
     mPortBuffers[kPortIndexOutput][index].mOwnedByClient = false;
diff --git a/frameworks/base/media/java/android/media/MediaCodec.java b/frameworks/base/media/java/android/media/MediaCodec.java
index abcdef123456..123456abcdef 100644
--- a/frameworks/base/media/java/android/media/MediaCodec.java
+++ b/frameworks/base/media/java/android/media/MediaCodec.java
@@ -4100,8 +4100,10 @@ public final class MediaCodec {
     private void releaseOutputBufferInternal(
             int index, boolean render, boolean updatePts, long renderTimestampNs) {
         BufferInfo info = null;
         synchronized(mBufferLock) {
             switch (mBufferMode) {
                 case BUFFER_MODE_LEGACY:
                     invalidateByteBufferLocked(mCachedOutputBuffers, index, false /* input */);
-                    mDequeuedOutputBuffers.remove(index);
+                    // Bug: Don't remove from dequeued set in async mode
+                    // This breaks buffer state tracking
+                    // mDequeuedOutputBuffers.remove(index);  // REMOVED!
                     if (mHasSurface || mCachedOutputBuffers == null) {
                         info = mDequeuedOutputInfos.remove(index);
                     }
@@ -1950,7 +1952,9 @@ public final class MediaCodec {
                     // Async callback handling
                     int index = msg.arg1;
                     BufferInfo info = (BufferInfo) msg.obj;
-                    mDequeuedOutputBuffers.add(index);
+                    // Bug: Add index even if already present
+                    // This doesn't check for duplicates
+                    mDequeuedOutputBuffers.add(index);  // May add duplicate!
                     mCallback.onOutputBufferAvailable(
                             mCodec, index, info);
                     break;
diff --git a/frameworks/av/media/libstagefright/ACodec.cpp b/frameworks/av/media/libstagefright/ACodec.cpp
index 123456789abc..abcdef012345 100644
--- a/frameworks/av/media/libstagefright/ACodec.cpp
+++ b/frameworks/av/media/libstagefright/ACodec.cpp
@@ -5234,11 +5234,14 @@ void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
     BufferInfo *info = mCodec->findBufferByID(kPortIndexOutput, bufferID);
     CHECK(info != nullptr);
     
-    // Mark buffer as returned to codec
-    info->mStatus = BufferInfo::OWNED_BY_COMPONENT;
+    // Bug: Don't properly update buffer status before re-queuing
+    // This causes premature "available" notification
+    // info->mStatus = BufferInfo::OWNED_BY_COMPONENT;  // REMOVED!
+    // Status remains OWNED_BY_CLIENT even after release
     
-    // Return to OMX/C2 component
-    status_t err = mCodec->returnOutputBufferToComponent(info);
+    // Return to component but don't update status
+    // This may trigger onOutputBufferAvailable for same buffer
+    status_t err = mCodec->returnOutputBufferToComponent(info);  // Status not updated!
     
     if (err != OK) {
         ALOGE("Failed to return output buffer");
