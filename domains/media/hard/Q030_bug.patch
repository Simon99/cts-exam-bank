diff --git a/frameworks/av/media/libstagefright/NuMediaExtractor.cpp b/frameworks/av/media/libstagefright/NuMediaExtractor.cpp
index 1234567890ab..abcdef123456 100644
--- a/frameworks/av/media/libstagefright/NuMediaExtractor.cpp
+++ b/frameworks/av/media/libstagefright/NuMediaExtractor.cpp
@@ -658,6 +658,9 @@ status_t NuMediaExtractor::appendVorbisNumPageSamples(
     uint32_t type;
     const void *data;
     size_t size, size2;
+    
+    // Bug: Only expand plainSizes, forget to expand encryptedSizes
+    // This causes array length mismatch in CryptoInfo
     if (mbuf->meta_data().findData(kKeyEncryptedSizes, &type, &data, &size)) {
         // Signal numPageSamples (a plain int32_t) is appended at the end,
         // i.e. sizeof(numPageSamples) plain bytes + 0 encrypted bytes
@@ -670,8 +673,8 @@ status_t NuMediaExtractor::appendVorbisNumPageSamples(
             return -ENOMEM;
         }
 
-        // append 0 to encrypted sizes
-        int32_t zero = 0;
+        // Bug: REMOVED - don't append 0 to encrypted sizes
+        // int32_t zero = 0;
         memcpy(adata, data, size);
-        memcpy(adata + size, &zero, sizeof(zero));
+        // memcpy(adata + size, &zero, sizeof(zero));  // REMOVED!
         mbuf->meta_data().setData(kKeyEncryptedSizes, type, adata, newSize);
@@ -682,11 +685,12 @@ status_t NuMediaExtractor::appendVorbisNumPageSamples(
             }
             memcpy(adata, data, size);
         } else {
             // if sample meta data does not include plain size array, assume filled with zeros,
             // i.e. entire buffer is encrypted
             memset(adata, 0, size);
         }
-        // append sizeof(numPageSamples) to plain sizes.
+        // append sizeof(numPageSamples) to plain sizes (but not to encrypted!)
+        // Bug: encryptedSizes is now 1 element shorter than plainSizes
         int32_t int32Size = sizeof(numPageSamples);
         memcpy(adata + size, &int32Size, sizeof(int32Size));
         mbuf->meta_data().setData(kKeyPlainSizes, type, adata, newSize);
diff --git a/frameworks/av/drm/libmediadrm/DrmHal.cpp b/frameworks/av/drm/libmediadrm/DrmHal.cpp
index abcdef123456..123456abcdef 100644
--- a/frameworks/av/drm/libmediadrm/DrmHal.cpp
+++ b/frameworks/av/drm/libmediadrm/DrmHal.cpp
@@ -234,15 +234,17 @@ DrmStatus DrmHal::decrypt(
     // Validate subsample data
     size_t numSubSamples = cryptoInfo.numSubSamples;
     
-    if (cryptoInfo.numBytesOfClearData.size() != numSubSamples ||
-        cryptoInfo.numBytesOfEncryptedData.size() != numSubSamples) {
-        ALOGE("CryptoInfo array size mismatch: clear=%zu, encrypted=%zu, expected=%zu",
-              cryptoInfo.numBytesOfClearData.size(),
-              cryptoInfo.numBytesOfEncryptedData.size(),
-              numSubSamples);
-        return DrmStatus(ERROR_MALFORMED);
-    }
+    // Bug: Remove validation, allow mismatched array sizes
+    // if (cryptoInfo.numBytesOfClearData.size() != numSubSamples ||
+    //     cryptoInfo.numBytesOfEncryptedData.size() != numSubSamples) {
+    //     ALOGE("CryptoInfo array size mismatch: clear=%zu, encrypted=%zu, expected=%zu",
+    //           cryptoInfo.numBytesOfClearData.size(),
+    //           cryptoInfo.numBytesOfEncryptedData.size(),
+    //           numSubSamples);
+    //     return DrmStatus(ERROR_MALFORMED);
+    // }
     
+    // Pass through without validation - allows bad data to reach Java
     return mDrmHalAidl->decrypt(sessionId, keyId, input, iv, subSamples, output);
 }
 
diff --git a/frameworks/base/media/java/android/media/MediaExtractor.java b/frameworks/base/media/java/android/media/MediaExtractor.java
index 123456789abc..abcdef012345 100644
--- a/frameworks/base/media/java/android/media/MediaExtractor.java
+++ b/frameworks/base/media/java/android/media/MediaExtractor.java
@@ -750,16 +750,19 @@ public final class MediaExtractor {
     private boolean populateCryptoInfo(MediaCodec.CryptoInfo info) {
         // Get crypto info from native
         int[] clearData = native_getSampleCryptoInfoClearData();
         int[] encryptedData = native_getSampleCryptoInfoEncryptedData();
         
-        // Validate array lengths match
-        if (clearData.length != encryptedData.length) {
-            Log.e(TAG, "CryptoInfo array length mismatch");
-            return false;
-        }
+        // Bug: Remove length validation
+        // Accept mismatched arrays from native layer
+        // if (clearData.length != encryptedData.length) {
+        //     Log.e(TAG, "CryptoInfo array length mismatch");
+        //     return false;
+        // }
         
         info.numSubSamples = clearData.length;
         info.numBytesOfClearData = clearData;
-        info.numBytesOfEncryptedData = encryptedData;
+        // Bug: Use mismatched encryptedData array
+        info.numBytesOfEncryptedData = encryptedData;  // Length may differ!
         
         return true;
     }
