#!/bin/bash
# CTS é¡Œç›®é©—è­‰è…³æœ¬ v2.5.3 â€” æ ¹æ“š Flash æ™‚é–“ç·šå¯¦é©—æ•¸æ“šå„ªåŒ–
# æ›´æ–°æ—¥æœŸ: 2026-02-21
# è®Šæ›´:
#   v2.5.3: ccache å‘½ä¸­ç‡æ”¹ç‚ºé¡¯ç¤ºã€Œç•¶å‰ buildã€å°ˆå±¬æ•¸æ“šï¼ˆè¨˜éŒ„åŸºæº–å€¼ï¼Œç®—å·®ç•°ï¼‰
#   v2.5.2: build é€²åº¦ webhook åŠ å…¥ ccache å‘½ä¸­ç‡
#   v2.5.1: åŠ å…¥ build é€²åº¦ webhookï¼ˆæ¯ 3 åˆ†é˜å ±å‘Šï¼‰ã€cleanup æ™‚çµ‚æ­¢å­é€²ç¨‹
#   v2.5: æ ¹æ“šå¯¦é©—æ•¸æ“šå„ªåŒ–ç­‰å¾…æ™‚é–“ã€åŠ å…¥ Pre-flash å¥åº·æª¢æŸ¥ã€flashall è¶…æ™‚ä¿è­·
#         æ”¹ç”¨é‚è¼¯ç­‰å¾…ï¼ˆsys.boot_completedï¼‰æ›¿ä»£å›ºå®š sleep
#   v2.4: åŠ å…¥ trap cleanupã€fastboot timeout+é‡è©¦ã€adb wait-for-device è¶…æ™‚
#   v2.3: PIPESTATUS ä¿®æ­£ã€patch è‡ªå‹•æª¢æ¸¬ã€cts_log_start
#
# å¯¦é©—æ•¸æ“šï¼ˆ2026-02-20ï¼‰:
#   - Flash æ™‚é–“: 102sï¼ˆç©©å®šï¼‰
#   - ADB å‡ºç¾: Flash å¾Œ +34s
#   - Boot å®Œæˆ: +50s (27161) / +38s (2B231)
#   - çµè«–: å¿…é ˆç”¨é‚è¼¯ç­‰å¾…ï¼Œä¸èƒ½ç”¨å›ºå®šç§’æ•¸
#
# ç”¨æ³•: cts-verify-v2.5.sh <é¡Œç›®è·¯å¾‘> [é¡Œç›®è·¯å¾‘...]
# ç¯„ä¾‹: CTS_DEVICE=27161FDH20031X ./cts-verify-v2.5.sh domains/display/hard/Q005

LOG_FILE="/tmp/cts_verify.log"
DEVICE="${CTS_DEVICE:-27161FDH20031X}"

# ============================================
# æ™‚é–“å¸¸æ•¸ï¼ˆæ ¹æ“šå¯¦é©—æ•¸æ“š 2026-02-20ï¼‰
# ============================================
FLASH_TIMEOUT=180           # Flash è¶…æ™‚ï¼ˆå¯¦æ¸¬ 102sï¼Œçµ¦ 1.8x é¤˜é‡ï¼‰
BOOTLOADER_TIMEOUT=30       # é€²å…¥ bootloader è¶…æ™‚
ADB_APPEAR_TIMEOUT=60       # ADB å‡ºç¾è¶…æ™‚ï¼ˆå¯¦æ¸¬ 34sï¼Œçµ¦ 1.8x é¤˜é‡ï¼‰
BOOT_COMPLETE_TIMEOUT=90    # Boot å®Œæˆè¶…æ™‚ï¼ˆå¯¦æ¸¬ 50sï¼Œçµ¦ 1.8x é¤˜é‡ï¼‰
BOOT_CHECK_INTERVAL=2       # Boot å®Œæˆæª¢æŸ¥é–“éš”ï¼ˆç§’ï¼‰
PRE_FLASH_ADB_TIMEOUT=10    # Pre-flash ADB æª¢æŸ¥è¶…æ™‚
USB_COOLDOWN=0              # USB å†·å»æœŸï¼ˆç§’ï¼‰ï¼Œè¨­ 0 é—œé–‰ï¼Œå»ºè­° 120 å¦‚æœé‡åˆ° USB å•é¡Œ

# ============================================
# è¨­å‚™ä¿è­·ï¼šè…³æœ¬ä¸­æ–·æ™‚å˜—è©¦æ•‘å›è¨­å‚™
# ============================================
cleanup() {
    log "è…³æœ¬ä¸­æ–·ï¼Œå˜—è©¦æ•‘å›è¨­å‚™..."
    # åœæ­¢ build ç›£æ§
    [ -n "$BUILD_MONITOR_PID" ] && kill $BUILD_MONITOR_PID 2>/dev/null
    # çµ‚æ­¢ç›¸é—œå­é€²ç¨‹ï¼ˆninja build ç­‰ï¼‰
    pkill -P $$ 2>/dev/null
    timeout 10 fastboot -s $DEVICE reboot 2>/dev/null || true
    timeout 10 adb -s $DEVICE reboot 2>/dev/null || true
}
trap cleanup INT TERM

SANDBOX="$HOME/develop_claw/aosp-sandbox-2"
CTS_PATH="$HOME/android-cts"
BACKUP_TOOL="$HOME/develop_claw/cts-exam-bank/tools/backup-cts-results.sh"
WEBHOOK_URL="https://discordapp.com/api/webhooks/1473692492133302322/X729Q-6zFcqrXu68SFxMBXMJJy99s9gqj3llCzeCdKMQy_vg2_JYWuSGeVIRX5Y6lol8"
WIFI_SSID="TP-LINK_5G_BA98"
WIFI_PASSWORD="2192191414"

export USE_ATS=false
export ANDROID_PRODUCT_OUT="$SANDBOX/out/target/product/panther"
export PATH="$SANDBOX/out/host/linux-x86/bin:$HOME/Android/Sdk/platform-tools:$PATH"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

notify() {
    local message="$1"
    curl -s -X POST "$WEBHOOK_URL" \
        -H "Content-Type: application/json" \
        -d "{\"content\":\"$message\"}" > /dev/null 2>&1
}

# ============================================
# v2.5.3 æ–°å¢ï¼šccache åŸºæº–å€¼è¨˜éŒ„ï¼ˆè¨ˆç®—ç•¶å‰ build å°ˆå±¬å‘½ä¸­ç‡ï¼‰
# ============================================
CCACHE_BASELINE_FILE="/tmp/ccache_baseline_$$"

record_ccache_baseline() {
    # è¨˜éŒ„ build é–‹å§‹å‰çš„ ccache hits/misses
    local hits=$(ccache -s 2>/dev/null | grep -E "^  Hits:" | head -1 | awk '{print $2}')
    local misses=$(ccache -s 2>/dev/null | grep -E "^  Misses:" | head -1 | awk '{print $2}')
    echo "${hits:-0} ${misses:-0}" > "$CCACHE_BASELINE_FILE"
    log "ccache åŸºæº–å€¼: hits=$hits, misses=$misses"
}

get_build_ccache_rate() {
    # è¨ˆç®—ç•¶å‰ build çš„å‘½ä¸­ç‡ï¼ˆç•¶å‰å€¼ - åŸºæº–å€¼ï¼‰
    if [ ! -f "$CCACHE_BASELINE_FILE" ]; then
        echo ""
        return
    fi
    local baseline=$(cat "$CCACHE_BASELINE_FILE")
    local base_hits=$(echo "$baseline" | awk '{print $1}')
    local base_misses=$(echo "$baseline" | awk '{print $2}')
    
    local curr_hits=$(ccache -s 2>/dev/null | grep -E "^  Hits:" | head -1 | awk '{print $2}')
    local curr_misses=$(ccache -s 2>/dev/null | grep -E "^  Misses:" | head -1 | awk '{print $2}')
    
    local build_hits=$((${curr_hits:-0} - ${base_hits:-0}))
    local build_misses=$((${curr_misses:-0} - ${base_misses:-0}))
    local total=$((build_hits + build_misses))
    
    if [ "$total" -gt 0 ]; then
        # ç”¨ awk è¨ˆç®—æµ®é»æ•¸ç™¾åˆ†æ¯”
        local rate=$(awk "BEGIN {printf \"%.1f\", ($build_hits / $total) * 100}")
        echo "${rate}% (${build_hits}/${total})"
    else
        echo "0% (0/0)"
    fi
}

# ============================================
# v2.5.1 æ–°å¢ï¼šBuild é€²åº¦ç›£æ§ï¼ˆèƒŒæ™¯åŸ·è¡Œï¼‰
# ============================================
BUILD_MONITOR_PID=""

start_build_monitor() {
    local q_id="$1"
    local interval="${2:-180}"  # é è¨­æ¯ 3 åˆ†é˜å ±å‘Šä¸€æ¬¡
    
    (
        local last_progress=""
        while true; do
            sleep "$interval"
            
            # æª¢æŸ¥ ninja æ˜¯å¦é‚„åœ¨è·‘
            if ! pgrep -f "ninja.*combined-aosp" > /dev/null; then
                break
            fi
            
            # å¾ ninja è¼¸å‡ºæ“·å–é€²åº¦
            local progress=$(ps aux | grep -E "ninja.*combined-aosp" | grep -v grep | head -1)
            if [ -n "$progress" ]; then
                # å˜—è©¦å¾æœ€è¿‘çš„ build.log æ“·å–é€²åº¦è¡Œ
                local progress_line=$(tail -20 "$SANDBOX/build.log" 2>/dev/null | grep -E "^\[.*%.*\]" | tail -1)
                if [ -n "$progress_line" ] && [ "$progress_line" != "$last_progress" ]; then
                    last_progress="$progress_line"
                    # å–å¾—ç•¶å‰ build çš„ ccache å‘½ä¸­ç‡ï¼ˆv2.5.3: ä½¿ç”¨å·®ç•°è¨ˆç®—ï¼‰
                    local ccache_rate=$(get_build_ccache_rate)
                    if [ -n "$ccache_rate" ]; then
                        notify "ğŸ”§ **$q_id** build é€²åº¦: \`$progress_line\` | ccache: ${ccache_rate}"
                    else
                        notify "ğŸ”§ **$q_id** build é€²åº¦: \`$progress_line\`"
                    fi
                else
                    # å¦‚æœæ²’æœ‰é€²åº¦è¡Œï¼Œå ±å‘Š ninja ä»åœ¨é‹è¡Œ
                    local elapsed=$(ps -o etimes= -p $(pgrep -f "ninja.*combined-aosp" | head -1) 2>/dev/null | tr -d ' ')
                    if [ -n "$elapsed" ]; then
                        local mins=$((elapsed / 60))
                        notify "ğŸ”§ **$q_id** build é€²è¡Œä¸­... (å·² ${mins} åˆ†é˜)"
                    fi
                fi
            fi
        done
    ) &
    BUILD_MONITOR_PID=$!
    log "[$q_id] Build ç›£æ§å•Ÿå‹• (PID: $BUILD_MONITOR_PID, é–“éš”: ${interval}s)"
}

stop_build_monitor() {
    if [ -n "$BUILD_MONITOR_PID" ]; then
        kill $BUILD_MONITOR_PID 2>/dev/null
        wait $BUILD_MONITOR_PID 2>/dev/null
        BUILD_MONITOR_PID=""
    fi
}

# ============================================
# v2.5 æ–°å¢ï¼šPre-flash å¥åº·æª¢æŸ¥
# ============================================
pre_flash_health_check() {
    local q_id="$1"
    log "[$q_id] Pre-flash å¥åº·æª¢æŸ¥..."
    
    # æª¢æŸ¥è¨­å‚™æ˜¯å¦å¯è¦‹
    if ! adb devices | grep -q "$DEVICE"; then
        log "[$q_id] âš ï¸ è¨­å‚™ $DEVICE ä¸åœ¨ adb devices ä¸­"
        
        # å˜—è©¦åœ¨ fastboot æ¨¡å¼æ‰¾
        if fastboot devices | grep -q "$DEVICE"; then
            log "[$q_id] è¨­å‚™åœ¨ fastboot æ¨¡å¼ï¼Œå˜—è©¦ reboot..."
            timeout 30 fastboot -s $DEVICE reboot 2>/dev/null
            sleep 30
            timeout 60 adb -s $DEVICE wait-for-device
        else
            log "[$q_id] âŒ è¨­å‚™å®Œå…¨ä¸å¯è¦‹ï¼Œè«‹æª¢æŸ¥ USB é€£æ¥"
            notify "âŒ **$q_id** è¨­å‚™ä¸å¯è¦‹ï¼Œè«‹æª¢æŸ¥ USB"
            return 1
        fi
    fi
    
    # æª¢æŸ¥ adb é€šè¨Šæ­£å¸¸
    if ! timeout $PRE_FLASH_ADB_TIMEOUT adb -s $DEVICE shell echo "ping" >/dev/null 2>&1; then
        log "[$q_id] âš ï¸ ADB ç„¡éŸ¿æ‡‰ï¼Œå˜—è©¦é‡å•Ÿ adb server..."
        adb kill-server
        sleep 2
        adb start-server
        sleep 3
        
        if ! timeout $PRE_FLASH_ADB_TIMEOUT adb -s $DEVICE shell echo "ping" >/dev/null 2>&1; then
            log "[$q_id] âŒ ADB ä»ç„¡éŸ¿æ‡‰"
            notify "âŒ **$q_id** ADB ç„¡éŸ¿æ‡‰"
            return 1
        fi
    fi
    
    log "[$q_id] âœ“ Pre-flash å¥åº·æª¢æŸ¥é€šé"
    return 0
}

# ============================================
# v2.5 æ–°å¢ï¼šç­‰å¾… boot å®Œæˆï¼ˆé‚è¼¯ç­‰å¾…ï¼‰
# ============================================
wait_for_boot_complete() {
    local q_id="$1"
    local timeout_sec="$2"
    local start_time=$(date +%s)
    
    log "[$q_id] ç­‰å¾…ç³»çµ±å•Ÿå‹•å®Œæˆï¼ˆæœ€å¤š ${timeout_sec}sï¼‰..."
    
    while true; do
        local elapsed=$(( $(date +%s) - start_time ))
        
        if [ $elapsed -gt $timeout_sec ]; then
            log "[$q_id] âŒ Boot è¶…æ™‚ï¼ˆ${timeout_sec}sï¼‰"
            return 1
        fi
        
        # æª¢æŸ¥ sys.boot_completed
        local boot_completed=$(adb -s $DEVICE shell getprop sys.boot_completed 2>/dev/null | tr -d '\r\n')
        
        if [ "$boot_completed" = "1" ]; then
            log "[$q_id] âœ“ ç³»çµ±å•Ÿå‹•å®Œæˆï¼ˆ${elapsed}sï¼‰"
            return 0
        fi
        
        sleep $BOOT_CHECK_INTERVAL
    done
}

# ============================================
# SKILL æ•´åˆï¼šccache ç’°å¢ƒè¨­å®š
# ============================================
setup_build_env() {
    log "è¨­å®šç·¨è­¯ç’°å¢ƒï¼ˆSKILL è¦ç¯„ï¼‰..."
    
    # ccache è¨­å®š
    export USE_CCACHE=1
    export CCACHE_DIR="${CCACHE_DIR:-$HOME/.ccache}"
    export CCACHE_EXEC=$(which ccache)
    
    if [ -z "$CCACHE_EXEC" ]; then
        log "âš ï¸ è­¦å‘Š: ccache æœªå®‰è£"
    else
        log "âœ“ ccache å·²å•Ÿç”¨: $CCACHE_DIR"
    fi
    
    # å›ºå®š BUILD_DATETIMEï¼ˆæ¶ˆé™¤æ™‚é–“å°è‡´çš„å·®ç•°ï¼‰
    export BUILD_DATETIME_FILE="$SANDBOX/.build_datetime"
    if [ ! -f "$BUILD_DATETIME_FILE" ]; then
        echo "$(date +%s)" > "$BUILD_DATETIME_FILE"
        log "âœ“ å»ºç«‹ BUILD_DATETIME_FILE"
    fi
    
    export BUILD_NUMBER="eng.$(whoami).$(date +%Y%m%d)"
}

wait_for_build() {
    log "ç­‰å¾…ç¾æœ‰ build å®Œæˆ..."
    notify "â³ ç­‰å¾…ç¾æœ‰ build å®Œæˆ..."
    while ps aux | grep -E "soong_ui --make-mode|ninja.*combined-aosp" | grep -v grep > /dev/null; do
        sleep 30
        log "Build ä»åœ¨é€²è¡Œä¸­..."
    done
    log "ç¾æœ‰ build å·²å®Œæˆ"
    notify "âœ… ç¾æœ‰ build å·²å®Œæˆ"
}

# ============================================
# SKILL æ•´åˆï¼šLevel 1 æ’æŸ¥ï¼ˆclean å–®æ¨¡çµ„é‡è©¦ï¼‰
# ============================================
do_build() {
    local q_id="$1"
    log "[$q_id] é–‹å§‹ build..."
    notify "ğŸ”¨ **$q_id** é–‹å§‹ build..."
    
    cd "$SANDBOX"
    
    # v2.5.3: è¨˜éŒ„ ccache åŸºæº–å€¼ï¼ˆç”¨æ–¼è¨ˆç®—ç•¶å‰ build å°ˆå±¬å‘½ä¸­ç‡ï¼‰
    record_ccache_baseline
    
    # å•Ÿå‹•èƒŒæ™¯é€²åº¦ç›£æ§ï¼ˆæ¯ 3 åˆ†é˜å ±å‘Šï¼‰
    start_build_monitor "$q_id" 180
    
    local start_time=$(date +%s)
    # èª¿ç”¨ aosp-incremental-build skillï¼ˆå·²å« ccacheã€envsetupã€lunchï¼‰
    AOSP_ROOT="$SANDBOX" ~/clawd/skills/aosp-incremental-build/scripts/daily_build.sh \
        aosp_panther-ap2a-userdebug 2>&1 | tee -a "$LOG_FILE"
    local build_result=${PIPESTATUS[0]}
    local end_time=$(date +%s)
    local duration=$(( (end_time - start_time) / 60 ))
    
    # åœæ­¢é€²åº¦ç›£æ§
    stop_build_monitor
    
    if [ $build_result -eq 0 ]; then
        local final_ccache=$(get_build_ccache_rate)
        log "[$q_id] Build å®Œæˆï¼Œè€—æ™‚ ${duration} åˆ†é˜ï¼Œccache: $final_ccache"
        notify "âœ… **$q_id** build å®Œæˆï¼Œè€—æ™‚ **${duration} åˆ†é˜** | ccache: ${final_ccache}"
        return 0
    fi
    
    # Build å¤±æ•—ï¼Œå¥—ç”¨ Level 1 æ’æŸ¥
    log "[$q_id] Build å¤±æ•—ï¼Œå•Ÿå‹• Level 1 æ’æŸ¥..."
    notify "âš ï¸ **$q_id** build å¤±æ•—ï¼Œå˜—è©¦ Level 1 æ’æŸ¥ï¼ˆclean æ¨¡çµ„å¾Œé‡è©¦ï¼‰..."
    
    # å¾éŒ¯èª¤ä¸­æå–å¤±æ•—çš„æ¨¡çµ„
    local failed_modules=$(grep -E "FAILED:|error:" "$LOG_FILE" | tail -10 | \
        grep -oE "[A-Za-z_-]+\.so|[A-Za-z_-]+\.apk|[A-Za-z_-]+\.jar" | \
        sed 's/\.so//;s/\.apk//;s/\.jar//' | sort -u | head -3)
    
    if [ -z "$failed_modules" ]; then
        failed_modules="framework services"
        log "[$q_id] ç„¡æ³•è­˜åˆ¥å¤±æ•—æ¨¡çµ„ï¼Œå˜—è©¦æ¸…ç†: $failed_modules"
    else
        log "[$q_id] è­˜åˆ¥åˆ°å¤±æ•—æ¨¡çµ„: $failed_modules"
    fi
    
    for module in $failed_modules; do
        log "[$q_id] Level 1: æ¸…ç†æ¨¡çµ„ $module..."
        m clean-$module 2>/dev/null
    done
    
    # é‡è©¦ buildï¼ˆèª¿ç”¨ aosp-incremental-build skillï¼‰
    log "[$q_id] Level 1: é‡è©¦ build..."
    start_time=$(date +%s)
    AOSP_ROOT="$SANDBOX" ~/clawd/skills/aosp-incremental-build/scripts/daily_build.sh \
        aosp_panther-ap2a-userdebug 2>&1 | tee -a "$LOG_FILE"
    build_result=${PIPESTATUS[0]}
    end_time=$(date +%s)
    duration=$(( (end_time - start_time) / 60 ))
    
    if [ $build_result -eq 0 ]; then
        local final_ccache=$(get_build_ccache_rate)
        log "[$q_id] Level 1 æ’æŸ¥å¾Œ build æˆåŠŸï¼Œè€—æ™‚ ${duration} åˆ†é˜ï¼Œccache: $final_ccache"
        notify "âœ… **$q_id** Level 1 æ’æŸ¥æˆåŠŸï¼Œbuild å®Œæˆï¼Œè€—æ™‚ **${duration} åˆ†é˜** | ccache: ${final_ccache}"
        return 0
    else
        log "[$q_id] Level 1 æ’æŸ¥å¾Œä»ç„¶å¤±æ•—"
        notify "âŒ **$q_id** Level 1 æ’æŸ¥å¤±æ•—ï¼Œéœ€è¦äººå·¥æª¢æŸ¥ log"
        return 1
    fi
}

# ============================================
# v2.5 é‡å¯«ï¼šflash_deviceï¼ˆæ ¹æ“šå¯¦é©—æ•¸æ“šå„ªåŒ–ï¼‰
# ============================================
flash_device() {
    local q_id="$1"
    
    # Pre-flash å¥åº·æª¢æŸ¥
    pre_flash_health_check "$q_id" || return 1
    
    log "[$q_id] é–‹å§‹ flash è¨­å‚™ $DEVICE..."
    notify "ğŸ“± **$q_id** é–‹å§‹ flash è¨­å‚™..."
    
    # é€²å…¥ bootloader
    log "[$q_id] é‡å•Ÿåˆ° bootloader..."
    adb -s $DEVICE reboot bootloader
    
    # ç­‰å¾…é€²å…¥ bootloaderï¼ˆç”¨è¼ªè©¢ä»£æ›¿ wait-for-deviceï¼Œå…¼å®¹æ€§æ›´å¥½ï¼‰
    log "[$q_id] ç­‰å¾…é€²å…¥ bootloaderï¼ˆæœ€å¤š ${BOOTLOADER_TIMEOUT}sï¼‰..."
    local wait_start=$(date +%s)
    while true; do
        if fastboot -s $DEVICE getvar product >/dev/null 2>&1; then
            break
        fi
        local elapsed=$(($(date +%s) - wait_start))
        if [ $elapsed -gt $BOOTLOADER_TIMEOUT ]; then
            log "[$q_id] âŒ é€²å…¥ bootloader è¶…æ™‚"
            notify "âŒ **$q_id** é€²å…¥ bootloader è¶…æ™‚"
            return 1
        fi
        sleep 1
    done
    
    # v2.5: å†æ¬¡ç¢ºèª fastboot é€šè¨Šæ­£å¸¸
    if ! timeout 10 fastboot -s $DEVICE getvar product >/dev/null 2>&1; then
        log "[$q_id] âš ï¸ Fastboot é€šè¨Šç•°å¸¸ï¼Œå¯èƒ½æ˜¯ USB å•é¡Œ"
        notify "âš ï¸ **$q_id** Fastboot é€šè¨Šç•°å¸¸ï¼Œè«‹æª¢æŸ¥ USB"
        return 1
    fi
    
    # v2.5: Flash åŠ è¶…æ™‚ä¿è­·ï¼ˆå¯¦æ¸¬ 102sï¼Œçµ¦ 180sï¼‰
    log "[$q_id] é–‹å§‹ flashï¼ˆè¶…æ™‚ ${FLASH_TIMEOUT}sï¼‰..."
    local flash_start=$(date +%s)
    
    timeout $FLASH_TIMEOUT fastboot -s $DEVICE flashall -w 2>&1 | tee -a "$LOG_FILE"
    local flash_result=${PIPESTATUS[0]}
    
    local flash_end=$(date +%s)
    local flash_duration=$((flash_end - flash_start))
    log "[$q_id] Flash è€—æ™‚: ${flash_duration}s"
    
    if [ $flash_result -eq 124 ]; then
        log "[$q_id] âŒ Flash è¶…æ™‚ï¼ˆ${FLASH_TIMEOUT}sï¼‰ï¼å¯èƒ½æ˜¯ USB å•é¡Œ"
        notify "âŒ **$q_id** flash è¶…æ™‚ï¼è«‹æª¢æŸ¥ USB é€£æ¥"
        return 1
    elif [ $flash_result -ne 0 ]; then
        log "[$q_id] âŒ Flash å¤±æ•—ï¼è¿”å›å€¼: $flash_result"
        notify "âŒ **$q_id** flash å¤±æ•—ï¼"
        return 1
    fi
    
    log "[$q_id] âœ“ Flash å®Œæˆï¼Œç­‰å¾…è¨­å‚™é‡å•Ÿ..."
    notify "âœ… **$q_id** flash å®Œæˆï¼ˆ${flash_duration}sï¼‰ï¼Œç­‰å¾…è¨­å‚™é–‹æ©Ÿ..."
    
    # v2.5: ç­‰å¾… ADB å‡ºç¾ï¼ˆå¯¦æ¸¬ 34sï¼Œçµ¦ 60sï¼‰
    log "[$q_id] ç­‰å¾… ADB å‡ºç¾ï¼ˆæœ€å¤š ${ADB_APPEAR_TIMEOUT}sï¼‰..."
    if ! timeout $ADB_APPEAR_TIMEOUT adb -s $DEVICE wait-for-device; then
        log "[$q_id] âŒ ADB å‡ºç¾è¶…æ™‚"
        notify "âš ï¸ **$q_id** ADB å‡ºç¾è¶…æ™‚ï¼Œè¨­å‚™å¯èƒ½å¡åœ¨ bootloader"
        
        # å˜—è©¦å¾ fastboot é‡å•Ÿ
        timeout $BOOTLOADER_TIMEOUT fastboot -s $DEVICE reboot 2>/dev/null || true
        sleep $PRE_FLASH_ADB_TIMEOUT
        
        if ! timeout $ADB_APPEAR_TIMEOUT adb -s $DEVICE wait-for-device; then
            log "[$q_id] âŒ è¨­å‚™ç„¡æ³•æ¢å¾©"
            notify "âŒ **$q_id** è¨­å‚™ç„¡æ³•æ¢å¾©ï¼Œè«‹æ‰‹å‹•æª¢æŸ¥"
            return 1
        fi
    fi
    
    # v2.5: ä½¿ç”¨é‚è¼¯ç­‰å¾…æ›¿ä»£å›ºå®š sleepï¼ˆå¯¦æ¸¬ boot å®Œæˆ +50sï¼‰
    wait_for_boot_complete "$q_id" "$BOOT_COMPLETE_TIMEOUT" || {
        notify "âš ï¸ **$q_id** Boot è¶…æ™‚ï¼Œå˜—è©¦ç¹¼çºŒ..."
        # ä¸ç›´æ¥ returnï¼Œå˜—è©¦ç¹¼çºŒ
    }
    
    log "[$q_id] è¨­å‚™å·²å°±ç·’"
    notify "ğŸ“± **$q_id** è¨­å‚™å·²å°±ç·’"
    
    # v2.5: USB å†·å»æœŸï¼ˆå¯é¸ï¼‰
    if [ "$USB_COOLDOWN" -gt 0 ]; then
        log "[$q_id] USB å†·å»æœŸï¼ˆ${USB_COOLDOWN}sï¼‰..."
        adb kill-server
        sleep $USB_COOLDOWN
        adb start-server
        sleep 3
    fi
    
    # è¨­ç½® WiFiï¼ˆCTS éœ€è¦ç¶²è·¯é€£ç·šï¼‰
    log "[$q_id] è¨­ç½® WiFi: $WIFI_SSID"
    notify "ğŸ“¶ **$q_id** è¨­ç½® WiFi..."
    
    sleep 5
    adb -s $DEVICE root
    sleep 3
    adb -s $DEVICE shell cmd wifi set-wifi-enabled enabled 2>&1 | tee -a "$LOG_FILE"
    sleep 3
    
    # å˜—è©¦é€£æ¥ WiFiï¼ˆæœ€å¤šé‡è©¦ 5 æ¬¡ï¼‰
    local wifi_connected=false
    for attempt in 1 2 3 4 5; do
        log "[$q_id] WiFi é€£æ¥å˜—è©¦ $attempt/5..."
        adb -s $DEVICE shell cmd wifi connect-network "$WIFI_SSID" wpa2 "$WIFI_PASSWORD" 2>&1 | tee -a "$LOG_FILE"
        sleep 8
        
        local wifi_status=$(adb -s $DEVICE shell cmd wifi status 2>&1)
        if echo "$wifi_status" | grep -qi "Wifi is connected"; then
            wifi_connected=true
            log "[$q_id] WiFi é€£æ¥æˆåŠŸï¼"
            notify "âœ… **$q_id** WiFi å·²é€£æ¥"
            break
        fi
        log "[$q_id] WiFi å°šæœªé€£æ¥ï¼Œç­‰å¾…é‡è©¦..."
        sleep 5
    done
    
    if [ "$wifi_connected" = false ]; then
        log "[$q_id] WiFi é€£æ¥å¤±æ•—ï¼Œç„¡æ³•ç¹¼çºŒ CTS"
        notify "âŒ **$q_id** WiFi é€£æ¥å¤±æ•—ï¼Œè·³éæ­¤é¡Œ"
        return 1
    fi
    
    return 0
}

run_cts() {
    local q_id="$1"
    local test_method="$2"
    
    log "[$q_id] é–‹å§‹åŸ·è¡Œ CTS: $test_method"
    notify "ğŸ§ª **$q_id** é–‹å§‹åŸ·è¡Œ CTS..."
    
    # è¨˜éŒ„ CTS é–‹å§‹ä½ç½®ï¼ˆé¿å… race conditionï¼‰
    local cts_log_start=$([ -f "$LOG_FILE" ] && wc -l < "$LOG_FILE" || echo "0")
    
    (
        unset ANDROID_BUILD_TOP ANDROID_HOST_OUT ANDROID_PRODUCT_OUT OUT_DIR TARGET_PRODUCT TARGET_BUILD_VARIANT
        cd "$CTS_PATH"
        
        if [ ! -f "./tools/cts-tradefed" ]; then
            echo "[$q_id] éŒ¯èª¤ï¼šæ‰¾ä¸åˆ° cts-tradefedï¼"
            exit 1
        fi
        
        ./tools/cts-tradefed run cts -m CtsDisplayTestCases -t "$test_method" -s $DEVICE
    ) 2>&1 | tee -a "$LOG_FILE"
    local cts_result=${PIPESTATUS[0]}
    
    if [ $cts_result -ne 0 ]; then
        log "[$q_id] CTS åŸ·è¡Œå¤±æ•—ï¼šè¿”å›å€¼ $cts_result"
        notify "âŒ **$q_id** CTS åŸ·è¡Œå¤±æ•—ï¼"
        return 1
    fi
    
    if grep -q "ClassNotFoundException\|Could not find or load main class" "$LOG_FILE"; then
        log "[$q_id] CTS åŸ·è¡Œå¤±æ•—ï¼šJava class è¼‰å…¥éŒ¯èª¤"
        notify "âŒ **$q_id** CTS åŸ·è¡Œå¤±æ•—ï¼šJava class è¼‰å…¥éŒ¯èª¤"
        return 1
    fi
    
    # è§£æ CTS çµæœï¼ˆåªè®€å–æœ¬æ¬¡ CTS çš„è¼¸å‡ºï¼‰
    local cts_output=$(tail -n +$((cts_log_start + 1)) "$LOG_FILE")
    local passed=$(echo "$cts_output" | grep -E "^PASSED\s*:" | grep -oP ':\s*\K\d+' || echo "0")
    local failed=$(echo "$cts_output" | grep -E "^FAILED\s*:" | grep -oP ':\s*\K\d+' || echo "0")
    passed=${passed:-0}
    failed=${failed:-0}
    
    if [ "$passed" = "0" ] && [ "$failed" = "0" ]; then
        log "[$q_id] CTS çµæœç•°å¸¸ï¼šæ²’æœ‰ä»»ä½•æ¸¬è©¦åŸ·è¡Œ"
        notify "âŒ **$q_id** CTS çµæœç•°å¸¸ï¼šæ²’æœ‰ä»»ä½•æ¸¬è©¦åŸ·è¡Œ"
        return 1
    fi
    
    log "[$q_id] CTS çµæœ: Passed=$passed, Failed=$failed"
    
    if [ "$failed" -gt 0 ]; then
        notify "ğŸ§ª **$q_id** CTS: âœ… Passed: $passed | âŒ Failed: $failedï¼ˆç¬¦åˆé æœŸï¼‰"
    else
        notify "âš ï¸ **$q_id** CTS: âœ… Passed: $passed | âŒ Failed: $failedï¼ˆæ³¨æ„ï¼šç„¡å¤±æ•—ï¼‰"
    fi
    return 0
}

verify_question() {
    local q_dir="$1"
    
    # è½‰æˆçµ•å°è·¯å¾‘ï¼ˆé¿å… cd å¾Œæ‰¾ä¸åˆ°ï¼‰
    if [[ "$q_dir" != /* ]]; then
        q_dir="$(cd "$(dirname "$q_dir")" && pwd)/$(basename "$q_dir")"
    fi
    
    local q_id=$(basename "$q_dir")
    
    # æª¢æŸ¥é¡Œç›®ç›®éŒ„
    if [ ! -d "$q_dir" ]; then
        log "[$q_id] éŒ¯èª¤ï¼šé¡Œç›®ç›®éŒ„ä¸å­˜åœ¨: $q_dir"
        notify "âŒ **$q_id** é¡Œç›®ç›®éŒ„ä¸å­˜åœ¨"
        return 1
    fi
    
    if [ ! -f "$q_dir/bug.patch" ] || [ ! -f "$q_dir/meta.json" ]; then
        log "[$q_id] éŒ¯èª¤ï¼šç¼ºå°‘ bug.patch æˆ– meta.json"
        notify "âŒ **$q_id** ç¼ºå°‘å¿…è¦æª”æ¡ˆ"
        return 1
    fi
    
    log "========== é–‹å§‹é©—è­‰ $q_id =========="
    log "[$q_id] é¡Œç›®ç›®éŒ„: $q_dir"
    notify "ğŸ”„ ========== é–‹å§‹é©—è­‰ **$q_id** =========="
    
    # è®€å– meta.json ç²å– test method
    local test_method=$(cat "$q_dir/meta.json" | grep '"cts_test"' | cut -d'"' -f4)
    log "[$q_id] CTS Test: $test_method"
    
    # é‚„åŸ sandbox
    log "[$q_id] é‚„åŸ sandbox..."
    notify "ğŸ”„ **$q_id** é‚„åŸ sandbox..."
    cd "$SANDBOX"
    repo forall -c 'git checkout .' 2>/dev/null
    rm -rf out/target/
    
    # å¥—ç”¨ patchï¼ˆè‡ªå‹•æª¢æ¸¬æ­£ç¢ºç›®éŒ„ï¼‰
    log "[$q_id] å¥—ç”¨ patch..."
    notify "ğŸ“ **$q_id** å¥—ç”¨ patch..."
    
    # å˜—è©¦å¾ sandbox æ ¹ç›®éŒ„ apply
    if patch --dry-run -p1 < "$q_dir/bug.patch" > /dev/null 2>&1; then
        patch -p1 < "$q_dir/bug.patch" 2>&1 | tee -a "$LOG_FILE"
        if [ "${PIPESTATUS[0]}" -ne 0 ]; then
            log "[$q_id] âŒ Patch failed from sandbox root!"
            notify "âŒ **$q_id** Patch å¥—ç”¨å¤±æ•—ï¼"
            return 1
        fi
        log "[$q_id] âœ“ Patch applied from sandbox root"
    # å˜—è©¦å¾ frameworks/base apply
    elif (cd frameworks/base && patch --dry-run -p1 < "$q_dir/bug.patch" > /dev/null 2>&1); then
        (cd frameworks/base && patch -p1 < "$q_dir/bug.patch") 2>&1 | tee -a "$LOG_FILE"
        if [ "${PIPESTATUS[0]}" -ne 0 ]; then
            log "[$q_id] âŒ Patch failed from frameworks/base!"
            notify "âŒ **$q_id** Patch å¥—ç”¨å¤±æ•—ï¼"
            return 1
        fi
        log "[$q_id] âœ“ Patch applied from frameworks/base"
    else
        log "[$q_id] âŒ Patch failed to apply!"
        notify "âŒ **$q_id** Patch å¥—ç”¨å¤±æ•—ï¼"
        return 1
    fi
    
    # Build
    do_build "$q_id" || return 1
    
    # Flash
    flash_device "$q_id" || return 1
    
    # CTS
    run_cts "$q_id" "$test_method" || return 1
    
    # å‚™ä»½ CTS çµæœå’Œ logs
    log "[$q_id] å‚™ä»½ CTS çµæœ..."
    
    # å¾è·¯å¾‘è§£æ domain å’Œ difficulty
    local domain=$(echo "$q_dir" | grep -oP 'domains/\K[^/]+')
    local difficulty=$(echo "$q_dir" | grep -oP 'domains/[^/]+/\K[^/]+')
    
    # å‚™ä»½ resultsï¼ˆä½¿ç”¨ latestï¼‰
    mkdir -p "$q_dir/cts_results"
    local latest_result=$(readlink -f "$CTS_PATH/results/latest")
    if [ -d "$latest_result" ]; then
        cp -r "$latest_result"/* "$q_dir/cts_results/"
        log "[$q_id] âœ“ å·²å‚™ä»½ CTS results"
    fi
    
    # å‚™ä»½ logs
    local latest_log=$(ls -td "$CTS_PATH/logs/"*/ 2>/dev/null | head -1)
    if [ -d "$latest_log" ]; then
        mkdir -p "$q_dir/cts_results/logs"
        cp -r "$latest_log"/* "$q_dir/cts_results/logs/"
        log "[$q_id] âœ“ å·²å‚™ä»½ CTS logs"
    fi
    
    # å»ºç«‹å‚™ä»½ metadata
    cat > "$q_dir/cts_results/backup_metadata.json" << EOF
{
  "backup_time": "$(date -Iseconds)",
  "question": "$q_id",
  "domain": "$domain",
  "difficulty": "$difficulty"
}
EOF
    notify "ğŸ“¦ **$q_id** å·²å‚™ä»½ CTS çµæœå’Œ logs"
    
    # æ›´æ–° meta.json
    if [ -f "$q_dir/meta.json" ]; then
        local today=$(date +%Y-%m-%d)
        # è§£æ CTS çµæœ
        local passed=$(tail -50 "$LOG_FILE" | grep -E "^PASSED\s*:" | grep -oP ':\s*\K\d+' || echo "0")
        local failed=$(tail -50 "$LOG_FILE" | grep -E "^FAILED\s*:" | grep -oP ':\s*\K\d+' || echo "0")
        local total=$((passed + failed))
        
        # ä½¿ç”¨ jq æ›´æ–°ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if command -v jq &> /dev/null; then
            local tmp_file=$(mktemp)
            jq --arg date "$today" --argjson passed "$passed" --argjson failed "$failed" --argjson total "$total" '
                .verification_status = "complete" |
                .verification_date = $date |
                .cts_summary = {passed: $passed, failed: $failed, total: $total} |
                del(.verification_issues)
            ' "$q_dir/meta.json" > "$tmp_file" && mv "$tmp_file" "$q_dir/meta.json"
            log "[$q_id] âœ“ å·²æ›´æ–° meta.json"
        else
            log "[$q_id] âš ï¸ jq æœªå®‰è£ï¼Œè·³é meta.json æ›´æ–°"
        fi
    fi
    
    log "========== $q_id é©—è­‰å®Œæˆ =========="
    notify "ğŸ‰ **$q_id** é©—è­‰å®Œæˆï¼"
}

# ==================== ä¸»æµç¨‹ ====================

if [ $# -eq 0 ]; then
    echo "ç”¨æ³•: $0 <é¡Œç›®è·¯å¾‘> [é¡Œç›®è·¯å¾‘...]"
    echo "ç¯„ä¾‹: CTS_DEVICE=27161FDH20031X $0 domains/display/hard/Q005"
    echo ""
    echo "ç’°å¢ƒè®Šæ•¸:"
    echo "  CTS_DEVICE      - è¨­å‚™åºè™Ÿï¼ˆé è¨­: 27161FDH20031Xï¼‰"
    echo "  USB_COOLDOWN    - USB å†·å»æœŸç§’æ•¸ï¼ˆé è¨­: 0ï¼Œå»ºè­°é‡åˆ° USB å•é¡Œæ™‚è¨­ 120ï¼‰"
    echo ""
    echo "æ™‚é–“å¸¸æ•¸ï¼ˆæ ¹æ“šå¯¦é©—æ•¸æ“š 2026-02-20ï¼‰:"
    echo "  FLASH_TIMEOUT=$FLASH_TIMEOUT (å¯¦æ¸¬ 102s)"
    echo "  BOOTLOADER_TIMEOUT=$BOOTLOADER_TIMEOUT"
    echo "  ADB_APPEAR_TIMEOUT=$ADB_APPEAR_TIMEOUT (å¯¦æ¸¬ 34s)"
    echo "  BOOT_COMPLETE_TIMEOUT=$BOOT_COMPLETE_TIMEOUT (å¯¦æ¸¬ 50s)"
    exit 1
fi

# å…ˆæŠŠæ‰€æœ‰ç›¸å°è·¯å¾‘è½‰æˆçµ•å°è·¯å¾‘ï¼ˆé¿å… cd å¾Œå¤±æ•ˆï¼‰
QUESTION_PATHS=()
for p in "$@"; do
    if [[ "$p" != /* ]]; then
        QUESTION_PATHS+=("$(pwd)/$p")
    else
        QUESTION_PATHS+=("$p")
    fi
done

> "$LOG_FILE"
log "=========================================="
log "CTS é©—è­‰è…³æœ¬ v2.5ï¼ˆFlash æ™‚é–“ç·šå¯¦é©—å„ªåŒ–ç‰ˆï¼‰"
log "è¨­å‚™: $DEVICE"
log "é¡Œç›®: ${QUESTION_PATHS[*]}"
log "=========================================="
log "æ™‚é–“å¸¸æ•¸: FLASH=$FLASH_TIMEOUT, BOOTLOADER=$BOOTLOADER_TIMEOUT, ADB=$ADB_APPEAR_TIMEOUT, BOOT=$BOOT_COMPLETE_TIMEOUT"
notify "ğŸš€ é–‹å§‹é©—è­‰: **${QUESTION_PATHS[*]}** (è¨­å‚™: $DEVICE)"

if ps aux | grep -E "soong_ui --make-mode|ninja.*combined-aosp" | grep -v grep > /dev/null; then
    wait_for_build
fi

for q_path in "${QUESTION_PATHS[@]}"; do
    verify_question "$q_path"
done

log "=========================================="
log "æ‰€æœ‰é©—è­‰å®Œæˆï¼"
log "=========================================="
notify "ğŸŠ **æ‰€æœ‰é©—è­‰å®Œæˆï¼** Log: \`/tmp/cts_verify.log\`"
